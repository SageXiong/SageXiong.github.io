title: 并发编程的实践（一）
date: 2019-11-09 10:15:51
comments: true
share: true
tags:
  - 并发
  - java   
categories:
  - 技术研究
password:
copyright: true
top: 0
---


## 前言
&emsp;&emsp;随着硬件的驱动以及国内互联网行业的飞速发展，现在 64 核的服务器已经飞入寻常百姓家，大型互联网厂商的系统并发量轻松过百万，传统的中间件和数据库已经不能为我们遮风挡雨，反而成了瓶颈所在。于是，并发编程已经慢慢成为一项必备技能;

## 并发编程三大核心问题
- **分工**：指的是如何高效地拆解任务并分配给线程；
- **同步**：指线程之间的如何协作；
- **互斥**：保证同一时刻只允许一个线程访问共享资源；

&emsp;&emsp;其实在Java SDK 并发包很大部分内容都是按照这三个维度组织的，例如 Fork/Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，而可重入锁则是一种互斥手段。

## 三大核心问题详解
### 分工

&emsp;&emsp;所谓分工，类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。在并发编程领域，你就是项目经理，线程就是项目组成员。任务分解和分工对于项目成败非常关键，不过在并发领域里，分工更重要，它直接决定了并发程序的性能。<br>
&emsp;&emsp;Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者 - 消费者、Thread-Per-Message、Worker Thread 模式等都是用来指导你如何分工的。<br>
&emsp;&emsp;学习这部分内容，最佳的方式就是和现实世界做对比。例如生产者 - 消费者模式，可以类比一下餐馆里的大厨和服务员，大厨就是生产者，负责做菜，做完放到出菜口，而服务员就是消费者，把做好的菜给你端过来。不过，我们经常会发现，出菜口有时候一下子出了好几个菜，服务员是可以把这一批菜同时端给你的。其实这就是生产者 - 消费者模式的一个优点，生产者一个一个地生产数据，而消费者可以批处理，这样就提高了性能。

### 同步
&emsp;&emsp;在并发编程领域里的同步，主要指的就是线程间的协作，本质上和现实生活中的协作没区别，不过是**一个线程执行完了一个任务，如何通知执行后续任务的线程开工**而已。<br>
&emsp;&emsp;协作一般是和分工相关的。Java SDK 并发包里的 Executor、Fork/Join、Future 本质上都是分工方法，但同时也能解决线程协作的问题。除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。<br>
&emsp;&emsp;工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：**当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行**。例如，在生产者 - 消费者模型里，也有类似的描述，“当队列满时，生产者线程等待，当队列不满时，生产者线程需要被唤醒执行；当队列空时，消费者线程等待，当队列不空时，消费者线程需要被唤醒执行。”<br>
&emsp;&emsp; 在 Java 并发编程领域，解决协作问题的核心技术是管程。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决下面我们将要介绍的互斥问题。可以这么说，**管程是解决并发问题的万能钥匙**。
 
### 互斥
&emsp;&emsp;分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语叫“**线程安全**”。并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。解决线程安全问题的核心方案就是互斥。<br>
&emsp;&emsp;**所谓互斥，指的是同一时刻，只允许一个线程访问共享变量**。<br>
&emsp;&emsp;实现互斥的核心技术就是锁，Java 语言里 synchronized、SDK 里的各种 Lock 都能解决互斥问题。虽说锁解决了安全性问题，但同时也带来了性能问题，Java SDK 里提供的 ReadWriteLock、StampedLock 就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如 Java SDK 里提供的原子类都是基于无锁技术实现的。<br>
### 三者的联系
&emsp;&emsp;在程序开发的工程中，我们为了提高执行计算机任务的效率，保证CPU充分利用，将任务拆分交替执行。从而出现并发，而CPU多核增加了并行计算，就出现**分工**的问题。分工以后为了进一步提升效率和更加灵活地达到目的，需要我们对线程组织编排，线程之间需要通信，而操作系统提供一些让进程，线程之间的通信方式，也就出现了**同步**的问题。但是事情总是会不尽如人意，并发和通信带来的高性能的同时，也带来了多线程操作的导致的共享资源竞争的问题。于是乎，为了解决这一问题，又将对共享资源串行化。所以就出现了**互斥**。<br>
&emsp;&emsp;综上，这一切均为提高性能的手段和对其所产生问题的解决方案。

![panoramic](https://upload-blog.oss-cn-shenzhen.aliyuncs.com/upload/java/concurrent/panoramic.png)
<center>并发编程全景图之思维导图</center>

## 参考：
极客时间 -> Java并发编程实战
